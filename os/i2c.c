
#include "i2c.h"

#define TWSR_MASK     0xfc  

volatile static uint8_t twiBuf[TWI_BUFFER_SIZE];  //байты, которые нужно загрузить
volatile static uint8_t twiState = TWI_NO_STATE;     //буфер состояний
volatile static uint8_t twiMsgSize;       //количество байт которые нужно загрузить

/*предделители для установки скорости обмена twi модуля*/
uint8_t pre[4] = {2, 8, 32, 128};

/****************************************************************************
 Инициализация и установка частоты SCL сигнала
****************************************************************************/
uint8_t TWI_MasterInit(uint16_t fr)  //получаем нужную частоту
{
	asm("cli");
	
  uint8_t i;       
  uint16_t twbrValue;   //наш предделитель?
  
  for(i = 0; i<4; i++){  //?
    twbrValue = ((((F_CPU)/1000UL)/fr)-16)/pre[i];   //расчет частоты , получается подбирает предделитель для ловли частоты, что за 1000ул - хз
    if ((twbrValue > 0)&& (twbrValue < 256)){		//проверка что значения BitRate 255<N>0
       TWBR = (uint8_t)twbrValue;  //задаем частоту, зачем в скобках юнитт?
       TWSR = i;  //i<4 предделитель частоты
       TWDR = 0xFF; // дата = 255 - зачем?
       TWCR = (1<<TWEN);   //включение прям тут
       return TWI_SUCCESS;
    }    //возвращает в успехе УСПЕХ или 0 при фейле
  }

     asm("sei");    
  return 0;  
}    






ISR(TWI_vect)
{
  assCLI;
  
  static uint8_t ptr;  // счетчик
  uint8_t stat = TWSR & TWSR_MASK;  //накладывание маски на делитель, чтоб остались только коды
  
  switch (stat){
	  
	  //  -------------------  старты, повторный старт    -------------------
	  
	  case TWI_START:                   // 0x08 - состояние СТАРТ успешно передано
	  case TWI_REP_START:               // 0x10 - состояние повторный СТАРТ спешно передано
	  ptr = 0;   //обнуление счетчика

      //-------------------   Передача-------------------
	  
	  case TWI_MTX_ADR_ACK:             // 0x18 - был передан адресный пакет SLA-W и получено подтверждение от ведомого
	  case TWI_MTX_DATA_ACK:            // 0x28 - был передан байт данных и получено подтверждение от ведомого
	  if (ptr < twiMsgSize){			//до тех пор, пока количество байт, которые нужно загрузить, меньше счетчика
		  TWDR = twiBuf[ptr];                    //загружаем в регистр данных следующий байт
		  TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT); //сбрасываем флаг TWINT
		  ptr++;
	  }
	  else{
		  twiState = TWI_SUCCESS;
		  TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWSTO)|(0<<TWIE); //формируем состояние СТОП, сбрасываем флаг, запрещаем прерывания
	  }
	  break;
	  
	  // -------------------   прием   -------------------
	  
	  case TWI_MRX_DATA_ACK:          //0x50 - был принят байт данных и отправлено подтверждение ведомому 
	  twiBuf[ptr] = TWDR;
	  ptr++;
	  
	  //-------------------  передал, но без ответа -------------------
	  
	  case TWI_MRX_ADR_ACK:           //0x40 - был передан адресный пакет SLA+R и получено подтверждение от ведомого
	  if (ptr < (twiMsgSize-1)){
		  TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWEA);  //если это не предпоследний принятый байт, формируем подтверждение
	  }
	  else {
		  TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT);            //если приняли предпоследний байт, подтверждение не формируем
	  }
	  break;
	  
	  //------------------- принял, но не ответил ------------------- 
	  
	  case TWI_MRX_DATA_NACK:       //0x58 - был принят байт данных без передачи подтверждения ведомому
	  twiBuf[ptr] = TWDR;
	  twiState = TWI_SUCCESS;     //0xff
	  TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWSTO); //формируем состояние стоп
	  break;
	  
	   //-------------------ошибки и всякая дичь-------------------
	   
	  case TWI_ARB_LOST:          //0x38 - потеря приоритета (это когда один или несколько ведущих начали передачу данных одновременно с нами и кто-то из них в итоге занял шину)
	  TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA); // сбрасываем флаг TWINT, формируем повторный СТАРТ
	  break;
	  	 
	  case TWI_MTX_ADR_NACK:      // 0x20 - был передан адресный пакет SLA-W без подтверждения ведомого
	  case TWI_MRX_ADR_NACK:      // 0x48 - был передан адресный пакет SLA+R без подтверждения ведомого
	  case TWI_MTX_DATA_NACK:     // 0x30 - был передан байт данных без подтверждения ведомого 
	  case TWI_BUS_ERROR:         // 0x00 - ошибка шины из-за некорректных состояний СТАРТ или СТОП 
	  default:
	  twiState = stat;
	  TWCR = (1<<TWEN)|(0<<TWIE)|(0<<TWINT)|(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|(0<<TWWC); //запретить прерывание
  }


    assSEI;   
}


/****************************************************************************
 Проверка - не занят ли TWI модуль. Используется внутри модуля
****************************************************************************/
static uint8_t TWI_TransceiverBusy(void)
{
	 
  return (TWCR & (1<<TWIE));      
             
}

/****************************************************************************
 Взять статус TWI модуля
****************************************************************************/
uint8_t TWI_GetState(void)
{ 
	
  while (TWI_TransceiverBusy());             
  return twiState;                        
}

/****************************************************************************
 Передать сообщение msg из msgSize байтов на TWI шину
****************************************************************************/

void TWI_SendData(uint8_t *msg, uint8_t msgSize)
{
	  assSEI; 
   uint8_t i;
 
   /*ждем ,когда TWI модуль освободится*/
    while(TWI_TransceiverBusy());  
 
   /*сохр. количество байт для передачи
   и первый байт сообщения*/
   twiMsgSize = msgSize;
   twiBuf[0] = msg[0]; 
 
   /*если первый байт типа SLA+W, то 
   остальное сообщение тоже сохраняем*/
   if (!(msg[0] & (TRUE<<TWI_READ_BIT))){ 
      for (i = 1; i < msgSize; i++){ 
         twiBuf[i] = msg[i];
      }
   }
 
   twiState = TWI_NO_STATE ;
 
   /*разрешаем прерывание и формируем состояние старт */
   TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)|(1<<TWSTA); 
   
   
}
	
	

	


/****************************************************************************
 Переписать полученные данные в буфер msg в количестве msgSize байт. 
****************************************************************************/
uint8_t TWI_GetData(uint8_t *msg, uint8_t msgSize)
{
	   assSEI; 
	 
	uint8_t i;


	while(TWI_TransceiverBusy());    //ждем, когда TWI модуль освободится

	if(twiState == TWI_SUCCESS){     //если сообщение успешно принято,
		for(i = 1; i < msgSize; i++){  //то переписываем его из внутреннего буфера в переданный
			msg[i+1] = twiBuf[i];  //ПОСТАВИЛ i=1 и msg i+1, сделано это для того, чтоб пропускать адрес и адрес памяти при записи. И не создавать дополнительные передаточные объекты
		}
	}
	
	
	return twiState;
}

